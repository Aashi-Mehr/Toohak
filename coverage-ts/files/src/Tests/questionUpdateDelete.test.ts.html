
  <!DOCTYPE html>
  <html>
    <head>
      <title>questionUpdateDelete.test.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">src/Tests/questionUpdateDelete.test.ts</td><td class="">95.70%</td><td class="">80%</td><td class="">1046</td><td class="">1001</td><td class="">45</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">import {
  AnswerBody,
  ErrorObject,
  QuestionBody
} from &#x27;../dataStore&#x27;;

import {
  requestClear,
  requestQuesDelete,
  requestQuesDup,
  requestQuesMove,
  requestQuesUpdate,
  requestQuestionCreate,
  requestQuizCreate,
  requestQuizInfo,
  requestQuizTransfer,
  requestRegister
} from &#x27;./testHelper&#x27;;

/** questionBody
  * Returns a questionBody object with given values
  *
  * @param { number } question - Optional question
  * @param { number } duration - Optional question duration
  * @param { number } points - Optional question points
  * @param { Question } answers - Optional questions answers
  *
  * @returns { QuestionBody } - All cases
  */
function questionBody(question?: string, duration?: number, points?: number,
  answers?: AnswerBody[]): QuestionBody {
  return {
    question: question || &#x27;What is the second letter of the alphabet?&#x27;,
    duration: duration || 10,
    points: points || 5,
    answers: answers || [{
      answer: &#x27;a&#x27;,
      correct: true
    },
    {
      answer: &#x27;b&#x27;,
      correct: false
    }]
  };
}

const shortQ = &#x27;Wha?&#x27;;
const longQ = &#x27;What is the first letter of the alphabettttttttttttttttttttttt?&#x27;;
const shortAnswers = [{ answer: &#x27;b&#x27;, correct: true }];
const longAnswers = [
  { answer: &#x27;b&#x27;, correct: true },
  { answer: &#x27;a&#x27;, correct: false },
  { answer: &#x27;c&#x27;, correct: false },
  { answer: &#x27;d&#x27;, correct: false },
  { answer: &#x27;e&#x27;, correct: false },
  { answer: &#x27;f&#x27;, correct: false },
  { answer: &#x27;g&#x27;, correct: false }
];

const initialQ = questionBody(&#x27;What is the first letter of the alphabet?&#x27;);
const finalQ = questionBody(undefined, 15, 10, [{ answer: &#x27;b&#x27;, correct: true },
  { answer: &#x27;a&#x27;, correct: false }]);

let token1: number;
let quizId1: number;
let questionId1: number;
let result: ErrorObject | Record&lt;string, never&gt;;

beforeEach(() =&gt; {
  // Clearing any previous data
  requestClear();

  // Defining base data to be manipulated in the tests (Updated/Deleted)
  token1 = requestRegister(&#x27;am@gmail.com&#x27;, &#x27;Vl1dPass&#x27;, &#x27;fir&#x27;, &#x27;las&#x27;).token;
  quizId1 = requestQuizCreate(token1, &#x27;New Quiz 1&#x27;, &#x27;&#x27;).quizId;
  questionId1 = requestQuestionCreate(token1, quizId1, initialQ).questionId;
});

describe(&#x27;adminQuizQuestionUpdate&#x27;, () =&gt; {
  // Error Checking

  test(&#x27;QuestionId does not refer to a valid question&#x27;, () =&gt; {
    // QuestionId does not refer to a valid question
    result = requestQuesUpdate(token1, quizId1, questionId1 + 1, finalQ);
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  test(&#x27;QuestionId does not refer to a valid question in this quiz&#x27;, () =&gt; {
    // QuestionId does not refer to a valid question in this quiz
    const quizId2 = requestQuizCreate(token1, &#x27;New Quiz 2&#x27;, &#x27;&#x27;).quizId;
    const questionId2 = requestQuestionCreate(token1, quizId2, finalQ).questionId;

    result = requestQuesUpdate(token1, quizId1, questionId2, initialQ);
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  test(&#x27;QuestionId is out of the valid range&#x27;, () =&gt; {
    // QuestionId is out of the valid range
    result = requestQuesUpdate(token1, quizId1, 0, finalQ);
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  test(&#x27;Question string is less than 5 characters in length&#x27;, () =&gt; {
    // Question string is less than 5 characters in length
    result = requestQuesUpdate(
      token1,
      quizId1,
      questionId1,
      questionBody(shortQ)
    );
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  test(&#x27;Question string is greater than 50 characters in length&#x27;, () =&gt; {
    // Question string is greater than 50 characters in length
    result = requestQuesUpdate(
      token1,
      quizId1,
      questionId1,
      questionBody(longQ)
    );
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  test(&#x27;The question has more than 6 answers&#x27;, () =&gt; {
    // The question has more than 6 answers
    result = requestQuesUpdate(token1, quizId1, questionId1, questionBody(
      undefined,
      undefined,
      undefined,
      longAnswers
    ));
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  test(&#x27;The question has less than 2 answers&#x27;, () =&gt; {
    // The question has less than 2 answers
    result = requestQuesUpdate(token1, quizId1, questionId1, questionBody(
      undefined,
      undefined,
      undefined,
      shortAnswers
    ));
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  test(&#x27;The question duration is not a positive number&#x27;, () =&gt; {
    // The question duration is not a positive number
    result = requestQuesUpdate(token1, quizId1, questionId1, questionBody(
      undefined, -1
    ));
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  test(&#x27;1 question duration is larger than 3 minutes&#x27;, () =&gt; {
    // 1 question duration is larger than 3 minutes
    result = requestQuesUpdate(token1, quizId1, questionId1, questionBody(
      undefined, 181
    ));
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  test(&#x27;The question duration is lerger than 3 minutes&#x27;, () =&gt; {
    // The question duration is lerger than 3 minutes
    const q2 = questionBody(&#x27;Question 2&#x27;, 30);
    const q3 = questionBody(&#x27;Question 3&#x27;, 30);
    const q4 = questionBody(&#x27;Question 4&#x27;, 30);
    const q5 = questionBody(&#x27;Question 5&#x27;, 30);
    const q6 = questionBody(&#x27;Question 6&#x27;, 30);

    requestQuestionCreate(token1, quizId1, q2);
    requestQuestionCreate(token1, quizId1, q3);
    requestQuestionCreate(token1, quizId1, q4);
    requestQuestionCreate(token1, quizId1, q5);
    requestQuestionCreate(token1, quizId1, q6);

    result = requestQuesUpdate(token1, quizId1, questionId1, questionBody(
      undefined, 31
    ));
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  test(&#x27;The points awarded for the question are less than 1&#x27;, () =&gt; {
    // The points awarded for the question are less than 1
    result = requestQuesUpdate(token1, quizId1, questionId1, questionBody(
      undefined, undefined, -1
    ));
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  test(&#x27;The points awarded for the question are greater than 10&#x27;, () =&gt; {
    // The points awarded for the question are greater than 10
    result = requestQuesUpdate(token1, quizId1, questionId1, questionBody(
      undefined, undefined, 11
    ));
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  test(&#x27;The length of any answer is shorter than 1 character&#x27;, () =&gt; {
    // The length of any answer is shorter than 1 character
    result = requestQuesUpdate(token1, quizId1, questionId1, questionBody(
      undefined, undefined, undefined,
      [{ answer: &#x27;&#x27;, correct: false }, { answer: &#x27;a&#x27;, correct: true }]
    ));
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  test(&#x27;The length of any answer is longer than 30 characters&#x27;, () =&gt; {
    // The length of any answer is longer than 30 characters
    result = requestQuesUpdate(token1, quizId1, questionId1, questionBody(
      undefined, undefined, undefined, [{ answer: &#x27;a&#x27;, correct: true },
        { answer: &#x27;1234567890123456789012345678901&#x27;, correct: true }]
    ));
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  test(&#x27;Answer strings are duplicated within the question once (1)&#x27;, () =&gt; {
    // Answer strings are duplicated within the question once
    result = requestQuesUpdate(token1, quizId1, questionId1, questionBody(
      undefined, undefined, undefined,
      [{ answer: &#x27;a&#x27;, correct: true }, { answer: &#x27;a&#x27;, correct: false }]
    ));
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  test(&#x27;Answer strings are duplicated within the question once (2)&#x27;, () =&gt; {
    // Answer strings are duplicated within the question
    result = requestQuesUpdate(token1, quizId1, questionId1, questionBody(
      undefined, undefined, undefined,
      [{ answer: &#x27;a&#x27;, correct: true }, { answer: &#x27;b&#x27;, correct: false },
        { answer: &#x27;c&#x27;, correct: false }, { answer: &#x27;b&#x27;, correct: false }]
    ));
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  test(&#x27;Answer strings are duplicated within the question&#x27;, () =&gt; {
    // Answer strings are duplicated within the question
    result = requestQuesUpdate(token1, quizId1, questionId1, questionBody(
      undefined, undefined, undefined,
      [{ answer: &#x27;a&#x27;, correct: true }, { answer: &#x27;b&#x27;, correct: false },
        { answer: &#x27;c&#x27;, correct: false }, { answer: &#x27;d&#x27;, correct: false },
        { answer: &#x27;a&#x27;, correct: false }, { answer: &#x27;b&#x27;, correct: false }]
    ));
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  test(&#x27;There are no correct answers&#x27;, () =&gt; {
    // There are no correct answers
    result = requestQuesUpdate(token1, quizId1, questionId1, questionBody(
      undefined, undefined, undefined,
      [{ answer: &#x27;a&#x27;, correct: false }, { answer: &#x27;a&#x27;, correct: false }]
    ));
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  test(&#x27;Token is empty&#x27;, () =&gt; {
    // Token is empty
    result = requestQuesUpdate(0, quizId1, questionId1, finalQ);
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  test(&#x27;Token does not refer to valid logged in user session&#x27;, () =&gt; {
    // Token does not refer to valid logged in user session
    result = requestQuesUpdate(token1 + 1, quizId1, questionId1, finalQ);
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  test(&#x27;Valid token is provided, but the user is unauthorised&#x27;, () =&gt; {
    // Valid token is provided, but the user is unauthorised
    const token2 = requestRegister(&#x27;a@gmail.com&#x27;, &#x27;Val1Pass&#x27;, &#x27;fir&#x27;, &#x27;las&#x27;).token;
    result = requestQuesUpdate(token2, quizId1, questionId1, finalQ);
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  test(&#x27;Valid token is provided, but unauthorised after transfer&#x27;, () =&gt; {
    // Valid token is provided, but unauthorised after transfer
    requestRegister(&#x27;a@gmail.com&#x27;, &#x27;Val1Pass&#x27;, &#x27;fir&#x27;, &#x27;las&#x27;);
    requestQuizTransfer(token1, quizId1, &#x27;a@gmail.com&#x27;);
    result = requestQuesUpdate(token1, quizId1, questionId1, finalQ);
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  // Valid Cases
  test(&#x27;Checking a simple case of restructuring a question&#x27;, () =&gt; {
    // Checking a simple case of restructuring a question
    result = requestQuesUpdate(token1, quizId1, questionId1, finalQ);
    expect(Object.keys(result).length).toStrictEqual(0);

    const info = requestQuizInfo(token1, quizId1);
    expect(info).toMatchObject({
      quizId: quizId1,
      name: &#x27;New Quiz 1&#x27;,
      timeCreated: expect.any(Number),
      timeLastEdited: expect.any(Number),
      description: &#x27;&#x27;,
      numQuestions: 1,
      questions: [{
        questionId: questionId1,
        question: &#x27;What is the second letter of the alphabet?&#x27;,
        duration: 15,
        points: 10,
        answers: [
          { answer: &#x27;b&#x27;, correct: true },
          { answer: &#x27;a&#x27;, correct: false }
        ]
      }],
      duration: 15
    });
  });

  test(&#x27;Updating the same question multiple times&#x27;, () =&gt; {
    // Updating multiple times
    requestQuesUpdate(token1, quizId1, questionId1, finalQ);
    requestQuesUpdate(token1, quizId1, questionId1, initialQ);
    result = requestQuesUpdate(token1, quizId1, questionId1, finalQ);
    expect(Object.keys(result).length).toStrictEqual(0);

    const info = requestQuizInfo(token1, quizId1);
    expect(info).toMatchObject({
      quizId: quizId1,
      name: &#x27;New Quiz 1&#x27;,
      timeCreated: expect.any(Number),
      timeLastEdited: expect.any(Number),
      description: &#x27;&#x27;,
      numQuestions: 1,
      questions: [{
        questionId: questionId1,
        question: &#x27;What is the second letter of the alphabet?&#x27;,
        duration: 15,
        points: 10,
        answers: [
          { answer: &#x27;b&#x27;, correct: true },
          { answer: &#x27;a&#x27;, correct: false }
        ]
      }],
      duration: 15
    });
  });

  test(&#x27;Moving, then updating&#x27;, () =&gt; {
    // Moving, then updating
    const question2 = requestQuestionCreate(token1, quizId1, initialQ);
    requestQuesMove(token1, 1, questionId1, quizId1);
    result = requestQuesUpdate(token1, quizId1, questionId1, finalQ);
    expect(Object.keys(result).length).toStrictEqual(0);

    const info = requestQuizInfo(token1, quizId1);
    expect(info).toMatchObject({
      quizId: quizId1,
      name: &#x27;New Quiz 1&#x27;,
      timeCreated: expect.any(Number),
      timeLastEdited: expect.any(Number),
      description: &#x27;&#x27;,
      numQuestions: 2,
      questions: [{
        questionId: question2.questionId,
        question: &#x27;What is the first letter of the alphabet?&#x27;,
        duration: 10,
        points: 5,
        answers: [
          { answer: &#x27;a&#x27;, correct: true },
          { answer: &#x27;b&#x27;, correct: false }
        ]
      },
      {
        questionId: questionId1,
        question: &#x27;What is the second letter of the alphabet?&#x27;,
        duration: 15,
        points: 10,
        answers: [
          { answer: &#x27;b&#x27;, correct: true },
          { answer: &#x27;a&#x27;, correct: false }
        ]
      }
      ],
      duration: 25
    });
  });

  test(&#x27;Duplicating, then updating&#x27;, () =&gt; {
    // Duplicating, then updating
    const question2 = requestQuesDup(token1, quizId1, questionId1);

    if (&#x27;questionId&#x27; in question2) {
      const questionId2 = question2.questionId;
      requestQuesUpdate(token1, quizId1, questionId1, finalQ);
      requestQuesUpdate(token1, quizId1, questionId2, finalQ);
      expect(Object.keys(result).length).toStrictEqual(0);

      const info = requestQuizInfo(token1, quizId1);
      expect(info).toMatchObject({
        quizId: quizId1,
        name: &#x27;New Quiz 1&#x27;,
        timeCreated: expect.any(Number),
        timeLastEdited: expect.any(Number),
        description: &#x27;&#x27;,
        numQuestions: 2,
        questions: [{
          questionId: questionId1,
          question: &#x27;What is the second letter of the alphabet?&#x27;,
          duration: 15,
          points: 10,
          answers: [
            { answer: &#x27;b&#x27;, correct: true },
            { answer: &#x27;a&#x27;, correct: false }
          ]
        },
        {
          questionId: questionId2,
          question: &#x27;What is the second letter of the alphabet?&#x27;,
          duration: 15,
          points: 10,
          answers: [
            { answer: &#x27;b&#x27;, correct: true },
            { answer: &#x27;a&#x27;, correct: false }
          ]
        }
        ],
        duration: 30
      });
    } else expect(question2).toMatchObject({ questionId: expect.any(Number) });
  });

  test(&#x27;Checking that question duration can be upto 180 seconds&#x27;, () =&gt; {
    // Checking that question duration can be upto 180 seconds
    const q2 = questionBody(&#x27;Question 2&#x27;, 30);
    const q3 = questionBody(&#x27;Question 3&#x27;, 30);
    const q4 = questionBody(&#x27;Question 4&#x27;, 30);
    const q5 = questionBody(&#x27;Question 5&#x27;, 30);
    const q6 = questionBody(&#x27;Question 6&#x27;, 30);

    requestQuestionCreate(token1, quizId1, q2);
    requestQuestionCreate(token1, quizId1, q3);
    requestQuestionCreate(token1, quizId1, q4);
    requestQuestionCreate(token1, quizId1, q5);
    requestQuestionCreate(token1, quizId1, q6);

    result = requestQuesUpdate(token1, quizId1, questionId1, questionBody(
      undefined, 30
    ));
    expect(Object.keys(result).length).toStrictEqual(0);

    const info = requestQuizInfo(token1, quizId1);
    expect(info.numQuestions).toStrictEqual(6);
    expect(info.duration).toStrictEqual(180);
  });
});

describe(&#x27;adminQuizQuestionDelete&#x27;, () =&gt; {
  // Error Checking

  test(&#x27;Question Id does not refer to a valid question&#x27;, () =&gt; {
    // Question Id does not refer to a valid question
    result = requestQuesDelete(token1, quizId1, questionId1 + 1);
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  test(&#x27;Question Id refers to a question that\&#x27;s already been deleted&#x27;, () =&gt; {
    // Question Id does not refer to a valid question
    requestQuesDelete(token1, quizId1, questionId1);
    result = requestQuesDelete(token1, quizId1, questionId1);
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  test(&#x27;QuestionId does not refer to a valid question in this quiz&#x27;, () =&gt; {
    // QuestionId does not refer to a valid question in this quiz
    const quizId2 = requestQuizCreate(token1, &#x27;New Quiz 2&#x27;, &#x27;&#x27;).quizId;
    const questionId2 = requestQuestionCreate(token1, quizId2, finalQ).questionId;

    result = requestQuesDelete(token1, quizId1, questionId2);
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  test(&#x27;QuestionId is out of the valid range&#x27;, () =&gt; {
    // QuestionId is out of the valid range
    result = requestQuesDelete(token1, quizId1, 0);
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  test(&#x27;Token is empty&#x27;, () =&gt; {
    // Token is empty
    result = requestQuesDelete(0, quizId1, questionId1);
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  test(&#x27;Token does not refer to valid logged in user session&#x27;, () =&gt; {
    // Token does not refer to valid logged in user session
    result = requestQuesDelete(token1 + 1, quizId1, questionId1);
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  test(&#x27;Valid token is provided, but the user is unauthorised&#x27;, () =&gt; {
    // Valid token is provided, but the user is unauthorised
    const token2 = requestRegister(&#x27;a@gmail.com&#x27;, &#x27;Val1Pass&#x27;, &#x27;fir&#x27;, &#x27;las&#x27;).token;
    result = requestQuesDelete(token2, quizId1, questionId1);
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  test(&#x27;Valid token is provided, but unauthorised after transfer&#x27;, () =&gt; {
    // Valid token is provided, but unauthorised after transfer
    requestRegister(&#x27;a@gmail.com&#x27;, &#x27;Val1Pass&#x27;, &#x27;fir&#x27;, &#x27;las&#x27;);
    requestQuizTransfer(token1, quizId1, &#x27;a@gmail.com&#x27;);
    result = requestQuesDelete(token1, quizId1, questionId1);
    expect(result).toMatchObject({ error: expect.any(String) });
  });

  // Valid Cases
  test(&#x27;Checking a simple case of deleting a question&#x27;, () =&gt; {
    // Checking a simple case of deleting a question
    result = requestQuesDelete(token1, quizId1, questionId1);
    expect(Object.keys(result).length).toStrictEqual(0);

    const info = requestQuizInfo(token1, quizId1);
    expect(info).toMatchObject({
      quizId: quizId1,
      name: &#x27;New Quiz 1&#x27;,
      timeCreated: expect.any(Number),
      timeLastEdited: expect.any(Number),
      description: &#x27;&#x27;,
      numQuestions: 0,
      questions: [],
      duration: 0
    });
  });

  test(&#x27;Duplicating, then deleting a question&#x27;, () =&gt; {
    // Duplicating, then deleting a question
    requestQuesDup(token1, quizId1, questionId1);
    result = requestQuesDelete(token1, quizId1, questionId1);
    expect(Object.keys(result).length).toStrictEqual(0);

    const info = requestQuizInfo(token1, quizId1);
    expect(info).toMatchObject({
      quizId: quizId1,
      name: &#x27;New Quiz 1&#x27;,
      timeCreated: expect.any(Number),
      timeLastEdited: expect.any(Number),
      description: &#x27;&#x27;,
      numQuestions: 1,
      questions: [{
        question: &#x27;What is the first letter of the alphabet?&#x27;,
        duration: 10,
        points: 5,
        answers: [
          { answer: &#x27;a&#x27;, correct: true },
          { answer: &#x27;b&#x27;, correct: false }
        ]
      }],
      duration: 10
    });
  });

  test(&#x27;Updating, then deleting a question&#x27;, () =&gt; {
    // Updating, then deleting a question
    requestQuesUpdate(token1, quizId1, questionId1, finalQ);
    result = requestQuesDelete(token1, quizId1, questionId1);
    expect(Object.keys(result).length).toStrictEqual(0);

    const info = requestQuizInfo(token1, quizId1);
    expect(info).toMatchObject({
      quizId: quizId1,
      name: &#x27;New Quiz 1&#x27;,
      timeCreated: expect.any(Number),
      timeLastEdited: expect.any(Number),
      description: &#x27;&#x27;,
      numQuestions: 0,
      questions: [],
      duration: 0
    });
  });
});
</textarea><pre id="annotations" style="display:none">[{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:84,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:93,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:99,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:110,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:121,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:132,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:143,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:151,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:159,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:179,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:187,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:195,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:204,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:213,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:222,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:232,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:243,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:252,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:258,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:264,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:271,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:279,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:292,&quot;character&quot;:6,&quot;text&quot;:&quot;timeCreated&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:293,&quot;character&quot;:6,&quot;text&quot;:&quot;timeLastEdited&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:321,&quot;character&quot;:6,&quot;text&quot;:&quot;timeCreated&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:322,&quot;character&quot;:6,&quot;text&quot;:&quot;timeLastEdited&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:350,&quot;character&quot;:6,&quot;text&quot;:&quot;timeCreated&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:351,&quot;character&quot;:6,&quot;text&quot;:&quot;timeLastEdited&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:393,&quot;character&quot;:8,&quot;text&quot;:&quot;timeCreated&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:394,&quot;character&quot;:8,&quot;text&quot;:&quot;timeLastEdited&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:420,&quot;character&quot;:45,&quot;text&quot;:&quot;questionId&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:454,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:461,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:470,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:476,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:482,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:488,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:495,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:503,&quot;character&quot;:35,&quot;text&quot;:&quot;error&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:516,&quot;character&quot;:6,&quot;text&quot;:&quot;timeCreated&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:517,&quot;character&quot;:6,&quot;text&quot;:&quot;timeLastEdited&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:535,&quot;character&quot;:6,&quot;text&quot;:&quot;timeCreated&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:536,&quot;character&quot;:6,&quot;text&quot;:&quot;timeLastEdited&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:562,&quot;character&quot;:6,&quot;text&quot;:&quot;timeCreated&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/Tests/questionUpdateDelete.test.ts&quot;,&quot;line&quot;:563,&quot;character&quot;:6,&quot;text&quot;:&quot;timeLastEdited&quot;,&quot;kind&quot;:1}]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Wed, 01 Nov 2023 00:14:18 GMT</p>
    </body>
  </html>
  